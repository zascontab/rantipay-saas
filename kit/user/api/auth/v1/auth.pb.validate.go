// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: user/api/auth/v1/auth.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RegisterAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterAuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterAuthRequestMultiError, or nil if none found.
func (m *RegisterAuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterAuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUsername()) < 1 {
		err := RegisterAuthRequestValidationError{
			field:  "Username",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 1 {
		err := RegisterAuthRequestValidationError{
			field:  "Password",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetConfirmPassword()) < 1 {
		err := RegisterAuthRequestValidationError{
			field:  "ConfirmPassword",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Web

	if len(errors) > 0 {
		return RegisterAuthRequestMultiError(errors)
	}

	return nil
}

// RegisterAuthRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterAuthRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterAuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterAuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterAuthRequestMultiError) AllErrors() []error { return m }

// RegisterAuthRequestValidationError is the validation error returned by
// RegisterAuthRequest.Validate if the designated constraints aren't met.
type RegisterAuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterAuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterAuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterAuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterAuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterAuthRequestValidationError) ErrorName() string {
	return "RegisterAuthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterAuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterAuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterAuthRequestValidationError{}

// Validate checks the field values on RegisterAuthReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RegisterAuthReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterAuthReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterAuthReplyMultiError, or nil if none found.
func (m *RegisterAuthReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterAuthReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for TokenType

	// no validation rules for RefreshToken

	// no validation rules for ExpiresIn

	if len(errors) > 0 {
		return RegisterAuthReplyMultiError(errors)
	}

	return nil
}

// RegisterAuthReplyMultiError is an error wrapping multiple validation errors
// returned by RegisterAuthReply.ValidateAll() if the designated constraints
// aren't met.
type RegisterAuthReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterAuthReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterAuthReplyMultiError) AllErrors() []error { return m }

// RegisterAuthReplyValidationError is the validation error returned by
// RegisterAuthReply.Validate if the designated constraints aren't met.
type RegisterAuthReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterAuthReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterAuthReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterAuthReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterAuthReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterAuthReplyValidationError) ErrorName() string {
	return "RegisterAuthReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterAuthReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterAuthReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterAuthReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterAuthReplyValidationError{}

// Validate checks the field values on LoginAuthRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LoginAuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginAuthRequestMultiError, or nil if none found.
func (m *LoginAuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginAuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUsername()) < 1 {
		err := LoginAuthRequestValidationError{
			field:  "Username",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 1 {
		err := LoginAuthRequestValidationError{
			field:  "Password",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Remember

	if len(errors) > 0 {
		return LoginAuthRequestMultiError(errors)
	}

	return nil
}

// LoginAuthRequestMultiError is an error wrapping multiple validation errors
// returned by LoginAuthRequest.ValidateAll() if the designated constraints
// aren't met.
type LoginAuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginAuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginAuthRequestMultiError) AllErrors() []error { return m }

// LoginAuthRequestValidationError is the validation error returned by
// LoginAuthRequest.Validate if the designated constraints aren't met.
type LoginAuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginAuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginAuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginAuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginAuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginAuthRequestValidationError) ErrorName() string { return "LoginAuthRequestValidationError" }

// Error satisfies the builtin error interface
func (e LoginAuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginAuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginAuthRequestValidationError{}

// Validate checks the field values on TokenRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TokenRequestMultiError, or
// nil if none found.
func (m *TokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _TokenRequest_GrantType_InLookup[m.GetGrantType()]; !ok {
		err := TokenRequestValidationError{
			field:  "GrantType",
			reason: "value must be in list [ password refresh_token authorization_code]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Username

	// no validation rules for Password

	// no validation rules for RefreshToken

	if len(errors) > 0 {
		return TokenRequestMultiError(errors)
	}

	return nil
}

// TokenRequestMultiError is an error wrapping multiple validation errors
// returned by TokenRequest.ValidateAll() if the designated constraints aren't met.
type TokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenRequestMultiError) AllErrors() []error { return m }

// TokenRequestValidationError is the validation error returned by
// TokenRequest.Validate if the designated constraints aren't met.
type TokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenRequestValidationError) ErrorName() string { return "TokenRequestValidationError" }

// Error satisfies the builtin error interface
func (e TokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenRequestValidationError{}

var _TokenRequest_GrantType_InLookup = map[string]struct{}{
	"":                   {},
	"password":           {},
	"refresh_token":      {},
	"authorization_code": {},
}

// Validate checks the field values on TokenReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TokenReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TokenReplyMultiError, or
// nil if none found.
func (m *TokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for TokenType

	// no validation rules for RefreshToken

	// no validation rules for ExpiresIn

	if len(errors) > 0 {
		return TokenReplyMultiError(errors)
	}

	return nil
}

// TokenReplyMultiError is an error wrapping multiple validation errors
// returned by TokenReply.ValidateAll() if the designated constraints aren't met.
type TokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TokenReplyMultiError) AllErrors() []error { return m }

// TokenReplyValidationError is the validation error returned by
// TokenReply.Validate if the designated constraints aren't met.
type TokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TokenReplyValidationError) ErrorName() string { return "TokenReplyValidationError" }

// Error satisfies the builtin error interface
func (e TokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TokenReplyValidationError{}

// Validate checks the field values on LoginAuthReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LoginAuthReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginAuthReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LoginAuthReplyMultiError,
// or nil if none found.
func (m *LoginAuthReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginAuthReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for TokenType

	// no validation rules for Expires

	// no validation rules for RefreshToken

	// no validation rules for ExpiresIn

	// no validation rules for Redirect

	if len(errors) > 0 {
		return LoginAuthReplyMultiError(errors)
	}

	return nil
}

// LoginAuthReplyMultiError is an error wrapping multiple validation errors
// returned by LoginAuthReply.ValidateAll() if the designated constraints
// aren't met.
type LoginAuthReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginAuthReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginAuthReplyMultiError) AllErrors() []error { return m }

// LoginAuthReplyValidationError is the validation error returned by
// LoginAuthReply.Validate if the designated constraints aren't met.
type LoginAuthReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginAuthReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginAuthReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginAuthReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginAuthReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginAuthReplyValidationError) ErrorName() string { return "LoginAuthReplyValidationError" }

// Error satisfies the builtin error interface
func (e LoginAuthReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginAuthReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginAuthReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginAuthReplyValidationError{}

// Validate checks the field values on RefreshTokenAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTokenAuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTokenAuthRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTokenAuthRequestMultiError, or nil if none found.
func (m *RefreshTokenAuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTokenAuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetRefreshToken()) < 1 {
		err := RefreshTokenAuthRequestValidationError{
			field:  "RefreshToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RefreshTokenAuthRequestMultiError(errors)
	}

	return nil
}

// RefreshTokenAuthRequestMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenAuthRequest.ValidateAll() if the designated
// constraints aren't met.
type RefreshTokenAuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenAuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenAuthRequestMultiError) AllErrors() []error { return m }

// RefreshTokenAuthRequestValidationError is the validation error returned by
// RefreshTokenAuthRequest.Validate if the designated constraints aren't met.
type RefreshTokenAuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenAuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenAuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenAuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenAuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenAuthRequestValidationError) ErrorName() string {
	return "RefreshTokenAuthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenAuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenAuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenAuthRequestValidationError{}

// Validate checks the field values on RefreshTokenAuthReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshTokenAuthReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshTokenAuthReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshTokenAuthReplyMultiError, or nil if none found.
func (m *RefreshTokenAuthReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshTokenAuthReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for TokenType

	// no validation rules for RefreshToken

	// no validation rules for ExpiresIn

	if len(errors) > 0 {
		return RefreshTokenAuthReplyMultiError(errors)
	}

	return nil
}

// RefreshTokenAuthReplyMultiError is an error wrapping multiple validation
// errors returned by RefreshTokenAuthReply.ValidateAll() if the designated
// constraints aren't met.
type RefreshTokenAuthReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshTokenAuthReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshTokenAuthReplyMultiError) AllErrors() []error { return m }

// RefreshTokenAuthReplyValidationError is the validation error returned by
// RefreshTokenAuthReply.Validate if the designated constraints aren't met.
type RefreshTokenAuthReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshTokenAuthReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshTokenAuthReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshTokenAuthReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshTokenAuthReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshTokenAuthReplyValidationError) ErrorName() string {
	return "RefreshTokenAuthReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshTokenAuthReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshTokenAuthReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshTokenAuthReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshTokenAuthReplyValidationError{}

// Validate checks the field values on PasswordlessTokenAuthRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PasswordlessTokenAuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordlessTokenAuthRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PasswordlessTokenAuthRequestMultiError, or nil if none found.
func (m *PasswordlessTokenAuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordlessTokenAuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Phone != nil {

		if all {
			switch v := interface{}(m.GetPhone()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PasswordlessTokenAuthRequestValidationError{
						field:  "Phone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PasswordlessTokenAuthRequestValidationError{
						field:  "Phone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPhone()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PasswordlessTokenAuthRequestValidationError{
					field:  "Phone",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Email != nil {

		if wrapper := m.GetEmail(); wrapper != nil {

			if err := m._validateEmail(wrapper.GetValue()); err != nil {
				err = PasswordlessTokenAuthRequestValidationError{
					field:  "Email",
					reason: "value must be a valid email address",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

		}

	}

	if len(errors) > 0 {
		return PasswordlessTokenAuthRequestMultiError(errors)
	}

	return nil
}

func (m *PasswordlessTokenAuthRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *PasswordlessTokenAuthRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// PasswordlessTokenAuthRequestMultiError is an error wrapping multiple
// validation errors returned by PasswordlessTokenAuthRequest.ValidateAll() if
// the designated constraints aren't met.
type PasswordlessTokenAuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordlessTokenAuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordlessTokenAuthRequestMultiError) AllErrors() []error { return m }

// PasswordlessTokenAuthRequestValidationError is the validation error returned
// by PasswordlessTokenAuthRequest.Validate if the designated constraints
// aren't met.
type PasswordlessTokenAuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordlessTokenAuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordlessTokenAuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordlessTokenAuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordlessTokenAuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordlessTokenAuthRequestValidationError) ErrorName() string {
	return "PasswordlessTokenAuthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PasswordlessTokenAuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordlessTokenAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordlessTokenAuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordlessTokenAuthRequestValidationError{}

// Validate checks the field values on PasswordlessTokenAuthReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PasswordlessTokenAuthReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PasswordlessTokenAuthReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PasswordlessTokenAuthReplyMultiError, or nil if none found.
func (m *PasswordlessTokenAuthReply) ValidateAll() error {
	return m.validate(true)
}

func (m *PasswordlessTokenAuthReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExpire()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PasswordlessTokenAuthReplyValidationError{
					field:  "Expire",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PasswordlessTokenAuthReplyValidationError{
					field:  "Expire",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpire()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PasswordlessTokenAuthReplyValidationError{
				field:  "Expire",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PasswordlessTokenAuthReplyMultiError(errors)
	}

	return nil
}

// PasswordlessTokenAuthReplyMultiError is an error wrapping multiple
// validation errors returned by PasswordlessTokenAuthReply.ValidateAll() if
// the designated constraints aren't met.
type PasswordlessTokenAuthReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PasswordlessTokenAuthReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PasswordlessTokenAuthReplyMultiError) AllErrors() []error { return m }

// PasswordlessTokenAuthReplyValidationError is the validation error returned
// by PasswordlessTokenAuthReply.Validate if the designated constraints aren't met.
type PasswordlessTokenAuthReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PasswordlessTokenAuthReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PasswordlessTokenAuthReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PasswordlessTokenAuthReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PasswordlessTokenAuthReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PasswordlessTokenAuthReplyValidationError) ErrorName() string {
	return "PasswordlessTokenAuthReplyValidationError"
}

// Error satisfies the builtin error interface
func (e PasswordlessTokenAuthReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPasswordlessTokenAuthReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PasswordlessTokenAuthReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PasswordlessTokenAuthReplyValidationError{}

// Validate checks the field values on LoginPasswordlessRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginPasswordlessRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginPasswordlessRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginPasswordlessRequestMultiError, or nil if none found.
func (m *LoginPasswordlessRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginPasswordlessRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetToken()) < 1 {
		err := LoginPasswordlessRequestValidationError{
			field:  "Token",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Web

	if m.Phone != nil {

		if all {
			switch v := interface{}(m.GetPhone()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoginPasswordlessRequestValidationError{
						field:  "Phone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoginPasswordlessRequestValidationError{
						field:  "Phone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPhone()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoginPasswordlessRequestValidationError{
					field:  "Phone",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Email != nil {

		if all {
			switch v := interface{}(m.GetEmail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LoginPasswordlessRequestValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LoginPasswordlessRequestValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LoginPasswordlessRequestValidationError{
					field:  "Email",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LoginPasswordlessRequestMultiError(errors)
	}

	return nil
}

// LoginPasswordlessRequestMultiError is an error wrapping multiple validation
// errors returned by LoginPasswordlessRequest.ValidateAll() if the designated
// constraints aren't met.
type LoginPasswordlessRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginPasswordlessRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginPasswordlessRequestMultiError) AllErrors() []error { return m }

// LoginPasswordlessRequestValidationError is the validation error returned by
// LoginPasswordlessRequest.Validate if the designated constraints aren't met.
type LoginPasswordlessRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginPasswordlessRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginPasswordlessRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginPasswordlessRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginPasswordlessRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginPasswordlessRequestValidationError) ErrorName() string {
	return "LoginPasswordlessRequestValidationError"
}

// Error satisfies the builtin error interface
func (e LoginPasswordlessRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginPasswordlessRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginPasswordlessRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginPasswordlessRequestValidationError{}

// Validate checks the field values on LoginPasswordlessReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LoginPasswordlessReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LoginPasswordlessReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LoginPasswordlessReplyMultiError, or nil if none found.
func (m *LoginPasswordlessReply) ValidateAll() error {
	return m.validate(true)
}

func (m *LoginPasswordlessReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for TokenType

	// no validation rules for RefreshToken

	// no validation rules for ExpiresIn

	if len(errors) > 0 {
		return LoginPasswordlessReplyMultiError(errors)
	}

	return nil
}

// LoginPasswordlessReplyMultiError is an error wrapping multiple validation
// errors returned by LoginPasswordlessReply.ValidateAll() if the designated
// constraints aren't met.
type LoginPasswordlessReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LoginPasswordlessReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LoginPasswordlessReplyMultiError) AllErrors() []error { return m }

// LoginPasswordlessReplyValidationError is the validation error returned by
// LoginPasswordlessReply.Validate if the designated constraints aren't met.
type LoginPasswordlessReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LoginPasswordlessReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LoginPasswordlessReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LoginPasswordlessReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LoginPasswordlessReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LoginPasswordlessReplyValidationError) ErrorName() string {
	return "LoginPasswordlessReplyValidationError"
}

// Error satisfies the builtin error interface
func (e LoginPasswordlessReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLoginPasswordlessReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LoginPasswordlessReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LoginPasswordlessReplyValidationError{}

// Validate checks the field values on ForgetPasswordTokenRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ForgetPasswordTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForgetPasswordTokenRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ForgetPasswordTokenRequestMultiError, or nil if none found.
func (m *ForgetPasswordTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ForgetPasswordTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Phone != nil {

		if all {
			switch v := interface{}(m.GetPhone()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ForgetPasswordTokenRequestValidationError{
						field:  "Phone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ForgetPasswordTokenRequestValidationError{
						field:  "Phone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPhone()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ForgetPasswordTokenRequestValidationError{
					field:  "Phone",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Email != nil {

		if all {
			switch v := interface{}(m.GetEmail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ForgetPasswordTokenRequestValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ForgetPasswordTokenRequestValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ForgetPasswordTokenRequestValidationError{
					field:  "Email",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ForgetPasswordTokenRequestMultiError(errors)
	}

	return nil
}

// ForgetPasswordTokenRequestMultiError is an error wrapping multiple
// validation errors returned by ForgetPasswordTokenRequest.ValidateAll() if
// the designated constraints aren't met.
type ForgetPasswordTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForgetPasswordTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForgetPasswordTokenRequestMultiError) AllErrors() []error { return m }

// ForgetPasswordTokenRequestValidationError is the validation error returned
// by ForgetPasswordTokenRequest.Validate if the designated constraints aren't met.
type ForgetPasswordTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForgetPasswordTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForgetPasswordTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForgetPasswordTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForgetPasswordTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForgetPasswordTokenRequestValidationError) ErrorName() string {
	return "ForgetPasswordTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ForgetPasswordTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForgetPasswordTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForgetPasswordTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForgetPasswordTokenRequestValidationError{}

// Validate checks the field values on ForgetPasswordTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ForgetPasswordTokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForgetPasswordTokenReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ForgetPasswordTokenReplyMultiError, or nil if none found.
func (m *ForgetPasswordTokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ForgetPasswordTokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetExpire()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ForgetPasswordTokenReplyValidationError{
					field:  "Expire",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ForgetPasswordTokenReplyValidationError{
					field:  "Expire",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExpire()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ForgetPasswordTokenReplyValidationError{
				field:  "Expire",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ForgetPasswordTokenReplyMultiError(errors)
	}

	return nil
}

// ForgetPasswordTokenReplyMultiError is an error wrapping multiple validation
// errors returned by ForgetPasswordTokenReply.ValidateAll() if the designated
// constraints aren't met.
type ForgetPasswordTokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForgetPasswordTokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForgetPasswordTokenReplyMultiError) AllErrors() []error { return m }

// ForgetPasswordTokenReplyValidationError is the validation error returned by
// ForgetPasswordTokenReply.Validate if the designated constraints aren't met.
type ForgetPasswordTokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForgetPasswordTokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForgetPasswordTokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForgetPasswordTokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForgetPasswordTokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForgetPasswordTokenReplyValidationError) ErrorName() string {
	return "ForgetPasswordTokenReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ForgetPasswordTokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForgetPasswordTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForgetPasswordTokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForgetPasswordTokenReplyValidationError{}

// Validate checks the field values on ForgetPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ForgetPasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForgetPasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ForgetPasswordRequestMultiError, or nil if none found.
func (m *ForgetPasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ForgetPasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Token

	if m.Phone != nil {

		if all {
			switch v := interface{}(m.GetPhone()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ForgetPasswordRequestValidationError{
						field:  "Phone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ForgetPasswordRequestValidationError{
						field:  "Phone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPhone()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ForgetPasswordRequestValidationError{
					field:  "Phone",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Email != nil {

		if all {
			switch v := interface{}(m.GetEmail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ForgetPasswordRequestValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ForgetPasswordRequestValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ForgetPasswordRequestValidationError{
					field:  "Email",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ForgetPasswordRequestMultiError(errors)
	}

	return nil
}

// ForgetPasswordRequestMultiError is an error wrapping multiple validation
// errors returned by ForgetPasswordRequest.ValidateAll() if the designated
// constraints aren't met.
type ForgetPasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForgetPasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForgetPasswordRequestMultiError) AllErrors() []error { return m }

// ForgetPasswordRequestValidationError is the validation error returned by
// ForgetPasswordRequest.Validate if the designated constraints aren't met.
type ForgetPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForgetPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForgetPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForgetPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForgetPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForgetPasswordRequestValidationError) ErrorName() string {
	return "ForgetPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ForgetPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForgetPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForgetPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForgetPasswordRequestValidationError{}

// Validate checks the field values on ForgetPasswordReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ForgetPasswordReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ForgetPasswordReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ForgetPasswordReplyMultiError, or nil if none found.
func (m *ForgetPasswordReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ForgetPasswordReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChangePasswordToken

	if len(errors) > 0 {
		return ForgetPasswordReplyMultiError(errors)
	}

	return nil
}

// ForgetPasswordReplyMultiError is an error wrapping multiple validation
// errors returned by ForgetPasswordReply.ValidateAll() if the designated
// constraints aren't met.
type ForgetPasswordReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ForgetPasswordReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ForgetPasswordReplyMultiError) AllErrors() []error { return m }

// ForgetPasswordReplyValidationError is the validation error returned by
// ForgetPasswordReply.Validate if the designated constraints aren't met.
type ForgetPasswordReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ForgetPasswordReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ForgetPasswordReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ForgetPasswordReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ForgetPasswordReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ForgetPasswordReplyValidationError) ErrorName() string {
	return "ForgetPasswordReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ForgetPasswordReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sForgetPasswordReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ForgetPasswordReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ForgetPasswordReplyValidationError{}

// Validate checks the field values on ValidatePasswordRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValidatePasswordRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidatePasswordRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidatePasswordRequestMultiError, or nil if none found.
func (m *ValidatePasswordRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidatePasswordRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Password

	if len(errors) > 0 {
		return ValidatePasswordRequestMultiError(errors)
	}

	return nil
}

// ValidatePasswordRequestMultiError is an error wrapping multiple validation
// errors returned by ValidatePasswordRequest.ValidateAll() if the designated
// constraints aren't met.
type ValidatePasswordRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidatePasswordRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidatePasswordRequestMultiError) AllErrors() []error { return m }

// ValidatePasswordRequestValidationError is the validation error returned by
// ValidatePasswordRequest.Validate if the designated constraints aren't met.
type ValidatePasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidatePasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidatePasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidatePasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidatePasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidatePasswordRequestValidationError) ErrorName() string {
	return "ValidatePasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ValidatePasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidatePasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidatePasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidatePasswordRequestValidationError{}

// Validate checks the field values on ValidatePasswordReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ValidatePasswordReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidatePasswordReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidatePasswordReplyMultiError, or nil if none found.
func (m *ValidatePasswordReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidatePasswordReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	if len(errors) > 0 {
		return ValidatePasswordReplyMultiError(errors)
	}

	return nil
}

// ValidatePasswordReplyMultiError is an error wrapping multiple validation
// errors returned by ValidatePasswordReply.ValidateAll() if the designated
// constraints aren't met.
type ValidatePasswordReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidatePasswordReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidatePasswordReplyMultiError) AllErrors() []error { return m }

// ValidatePasswordReplyValidationError is the validation error returned by
// ValidatePasswordReply.Validate if the designated constraints aren't met.
type ValidatePasswordReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidatePasswordReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidatePasswordReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidatePasswordReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidatePasswordReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidatePasswordReplyValidationError) ErrorName() string {
	return "ValidatePasswordReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ValidatePasswordReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidatePasswordReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidatePasswordReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidatePasswordReplyValidationError{}

// Validate checks the field values on GetLoginRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLoginRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLoginRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLoginRequestMultiError, or nil if none found.
func (m *GetLoginRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLoginRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Redirect

	// no validation rules for LoginChallenge

	if len(errors) > 0 {
		return GetLoginRequestMultiError(errors)
	}

	return nil
}

// GetLoginRequestMultiError is an error wrapping multiple validation errors
// returned by GetLoginRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLoginRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLoginRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLoginRequestMultiError) AllErrors() []error { return m }

// GetLoginRequestValidationError is the validation error returned by
// GetLoginRequest.Validate if the designated constraints aren't met.
type GetLoginRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLoginRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLoginRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLoginRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLoginRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLoginRequestValidationError) ErrorName() string { return "GetLoginRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLoginRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLoginRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLoginRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLoginRequestValidationError{}

// Validate checks the field values on GetLoginResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetLoginResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLoginResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetLoginResponseMultiError, or nil if none found.
func (m *GetLoginResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLoginResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Redirect

	for idx, item := range m.GetOauth() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetLoginResponseValidationError{
						field:  fmt.Sprintf("Oauth[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetLoginResponseValidationError{
						field:  fmt.Sprintf("Oauth[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetLoginResponseValidationError{
					field:  fmt.Sprintf("Oauth[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Hint

	// no validation rules for Challenge

	if len(errors) > 0 {
		return GetLoginResponseMultiError(errors)
	}

	return nil
}

// GetLoginResponseMultiError is an error wrapping multiple validation errors
// returned by GetLoginResponse.ValidateAll() if the designated constraints
// aren't met.
type GetLoginResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLoginResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLoginResponseMultiError) AllErrors() []error { return m }

// GetLoginResponseValidationError is the validation error returned by
// GetLoginResponse.Validate if the designated constraints aren't met.
type GetLoginResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLoginResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLoginResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLoginResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLoginResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLoginResponseValidationError) ErrorName() string { return "GetLoginResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetLoginResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLoginResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLoginResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLoginResponseValidationError{}

// Validate checks the field values on OAuthProvider with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OAuthProvider) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OAuthProvider with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OAuthProviderMultiError, or
// nil if none found.
func (m *OAuthProvider) ValidateAll() error {
	return m.validate(true)
}

func (m *OAuthProvider) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return OAuthProviderMultiError(errors)
	}

	return nil
}

// OAuthProviderMultiError is an error wrapping multiple validation errors
// returned by OAuthProvider.ValidateAll() if the designated constraints
// aren't met.
type OAuthProviderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OAuthProviderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OAuthProviderMultiError) AllErrors() []error { return m }

// OAuthProviderValidationError is the validation error returned by
// OAuthProvider.Validate if the designated constraints aren't met.
type OAuthProviderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OAuthProviderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OAuthProviderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OAuthProviderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OAuthProviderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OAuthProviderValidationError) ErrorName() string { return "OAuthProviderValidationError" }

// Error satisfies the builtin error interface
func (e OAuthProviderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOAuthProvider.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OAuthProviderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OAuthProviderValidationError{}

// Validate checks the field values on GetCsrfTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCsrfTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCsrfTokenRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCsrfTokenRequestMultiError, or nil if none found.
func (m *GetCsrfTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCsrfTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetCsrfTokenRequestMultiError(errors)
	}

	return nil
}

// GetCsrfTokenRequestMultiError is an error wrapping multiple validation
// errors returned by GetCsrfTokenRequest.ValidateAll() if the designated
// constraints aren't met.
type GetCsrfTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCsrfTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCsrfTokenRequestMultiError) AllErrors() []error { return m }

// GetCsrfTokenRequestValidationError is the validation error returned by
// GetCsrfTokenRequest.Validate if the designated constraints aren't met.
type GetCsrfTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCsrfTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCsrfTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCsrfTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCsrfTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCsrfTokenRequestValidationError) ErrorName() string {
	return "GetCsrfTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetCsrfTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCsrfTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCsrfTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCsrfTokenRequestValidationError{}

// Validate checks the field values on GetCsrfTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetCsrfTokenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCsrfTokenResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCsrfTokenResponseMultiError, or nil if none found.
func (m *GetCsrfTokenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCsrfTokenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CsrfToken

	if len(errors) > 0 {
		return GetCsrfTokenResponseMultiError(errors)
	}

	return nil
}

// GetCsrfTokenResponseMultiError is an error wrapping multiple validation
// errors returned by GetCsrfTokenResponse.ValidateAll() if the designated
// constraints aren't met.
type GetCsrfTokenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCsrfTokenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCsrfTokenResponseMultiError) AllErrors() []error { return m }

// GetCsrfTokenResponseValidationError is the validation error returned by
// GetCsrfTokenResponse.Validate if the designated constraints aren't met.
type GetCsrfTokenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCsrfTokenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCsrfTokenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCsrfTokenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCsrfTokenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCsrfTokenResponseValidationError) ErrorName() string {
	return "GetCsrfTokenResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetCsrfTokenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCsrfTokenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCsrfTokenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCsrfTokenResponseValidationError{}

// Validate checks the field values on LogoutRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogoutRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutRequestMultiError, or
// nil if none found.
func (m *LogoutRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LogoutRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Challenge

	if len(errors) > 0 {
		return LogoutRequestMultiError(errors)
	}

	return nil
}

// LogoutRequestMultiError is an error wrapping multiple validation errors
// returned by LogoutRequest.ValidateAll() if the designated constraints
// aren't met.
type LogoutRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogoutRequestMultiError) AllErrors() []error { return m }

// LogoutRequestValidationError is the validation error returned by
// LogoutRequest.Validate if the designated constraints aren't met.
type LogoutRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogoutRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogoutRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogoutRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogoutRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogoutRequestValidationError) ErrorName() string { return "LogoutRequestValidationError" }

// Error satisfies the builtin error interface
func (e LogoutRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogoutRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogoutRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogoutRequestValidationError{}

// Validate checks the field values on LogoutResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogoutResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogoutResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogoutResponseMultiError,
// or nil if none found.
func (m *LogoutResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LogoutResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Redirect

	if len(errors) > 0 {
		return LogoutResponseMultiError(errors)
	}

	return nil
}

// LogoutResponseMultiError is an error wrapping multiple validation errors
// returned by LogoutResponse.ValidateAll() if the designated constraints
// aren't met.
type LogoutResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogoutResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogoutResponseMultiError) AllErrors() []error { return m }

// LogoutResponseValidationError is the validation error returned by
// LogoutResponse.Validate if the designated constraints aren't met.
type LogoutResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogoutResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogoutResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogoutResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogoutResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogoutResponseValidationError) ErrorName() string { return "LogoutResponseValidationError" }

// Error satisfies the builtin error interface
func (e LogoutResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogoutResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogoutResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogoutResponseValidationError{}

// Validate checks the field values on WebLoginAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WebLoginAuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebLoginAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebLoginAuthRequestMultiError, or nil if none found.
func (m *WebLoginAuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WebLoginAuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUsername()) < 1 {
		err := WebLoginAuthRequestValidationError{
			field:  "Username",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPassword()) < 1 {
		err := WebLoginAuthRequestValidationError{
			field:  "Password",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Remember

	// no validation rules for Challenge

	// no validation rules for Reject

	if len(errors) > 0 {
		return WebLoginAuthRequestMultiError(errors)
	}

	return nil
}

// WebLoginAuthRequestMultiError is an error wrapping multiple validation
// errors returned by WebLoginAuthRequest.ValidateAll() if the designated
// constraints aren't met.
type WebLoginAuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebLoginAuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebLoginAuthRequestMultiError) AllErrors() []error { return m }

// WebLoginAuthRequestValidationError is the validation error returned by
// WebLoginAuthRequest.Validate if the designated constraints aren't met.
type WebLoginAuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebLoginAuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebLoginAuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebLoginAuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebLoginAuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebLoginAuthRequestValidationError) ErrorName() string {
	return "WebLoginAuthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WebLoginAuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebLoginAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebLoginAuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebLoginAuthRequestValidationError{}

// Validate checks the field values on WebLoginAuthReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WebLoginAuthReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WebLoginAuthReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WebLoginAuthReplyMultiError, or nil if none found.
func (m *WebLoginAuthReply) ValidateAll() error {
	return m.validate(true)
}

func (m *WebLoginAuthReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccessToken

	// no validation rules for TokenType

	// no validation rules for Expires

	// no validation rules for RefreshToken

	// no validation rules for ExpiresIn

	// no validation rules for Redirect

	if len(errors) > 0 {
		return WebLoginAuthReplyMultiError(errors)
	}

	return nil
}

// WebLoginAuthReplyMultiError is an error wrapping multiple validation errors
// returned by WebLoginAuthReply.ValidateAll() if the designated constraints
// aren't met.
type WebLoginAuthReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WebLoginAuthReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WebLoginAuthReplyMultiError) AllErrors() []error { return m }

// WebLoginAuthReplyValidationError is the validation error returned by
// WebLoginAuthReply.Validate if the designated constraints aren't met.
type WebLoginAuthReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WebLoginAuthReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WebLoginAuthReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WebLoginAuthReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WebLoginAuthReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WebLoginAuthReplyValidationError) ErrorName() string {
	return "WebLoginAuthReplyValidationError"
}

// Error satisfies the builtin error interface
func (e WebLoginAuthReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWebLoginAuthReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WebLoginAuthReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WebLoginAuthReplyValidationError{}

// Validate checks the field values on ChangePasswordByForgetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangePasswordByForgetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangePasswordByForgetRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ChangePasswordByForgetRequestMultiError, or nil if none found.
func (m *ChangePasswordByForgetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangePasswordByForgetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetChangePasswordToken()) < 1 {
		err := ChangePasswordByForgetRequestValidationError{
			field:  "ChangePasswordToken",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNewPassword()) < 1 {
		err := ChangePasswordByForgetRequestValidationError{
			field:  "NewPassword",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetConfirmNewPassword()) < 1 {
		err := ChangePasswordByForgetRequestValidationError{
			field:  "ConfirmNewPassword",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChangePasswordByForgetRequestMultiError(errors)
	}

	return nil
}

// ChangePasswordByForgetRequestMultiError is an error wrapping multiple
// validation errors returned by ChangePasswordByForgetRequest.ValidateAll()
// if the designated constraints aren't met.
type ChangePasswordByForgetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangePasswordByForgetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangePasswordByForgetRequestMultiError) AllErrors() []error { return m }

// ChangePasswordByForgetRequestValidationError is the validation error
// returned by ChangePasswordByForgetRequest.Validate if the designated
// constraints aren't met.
type ChangePasswordByForgetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangePasswordByForgetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangePasswordByForgetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangePasswordByForgetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangePasswordByForgetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangePasswordByForgetRequestValidationError) ErrorName() string {
	return "ChangePasswordByForgetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ChangePasswordByForgetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangePasswordByForgetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangePasswordByForgetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangePasswordByForgetRequestValidationError{}

// Validate checks the field values on ChangePasswordByForgetReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangePasswordByForgetReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangePasswordByForgetReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangePasswordByForgetReplyMultiError, or nil if none found.
func (m *ChangePasswordByForgetReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangePasswordByForgetReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ChangePasswordByForgetReplyMultiError(errors)
	}

	return nil
}

// ChangePasswordByForgetReplyMultiError is an error wrapping multiple
// validation errors returned by ChangePasswordByForgetReply.ValidateAll() if
// the designated constraints aren't met.
type ChangePasswordByForgetReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangePasswordByForgetReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangePasswordByForgetReplyMultiError) AllErrors() []error { return m }

// ChangePasswordByForgetReplyValidationError is the validation error returned
// by ChangePasswordByForgetReply.Validate if the designated constraints
// aren't met.
type ChangePasswordByForgetReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangePasswordByForgetReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangePasswordByForgetReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangePasswordByForgetReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangePasswordByForgetReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangePasswordByForgetReplyValidationError) ErrorName() string {
	return "ChangePasswordByForgetReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ChangePasswordByForgetReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangePasswordByForgetReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangePasswordByForgetReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangePasswordByForgetReplyValidationError{}

// Validate checks the field values on ChangePasswordByPreRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangePasswordByPreRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangePasswordByPreRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangePasswordByPreRequestMultiError, or nil if none found.
func (m *ChangePasswordByPreRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangePasswordByPreRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetPrePassword()) < 1 {
		err := ChangePasswordByPreRequestValidationError{
			field:  "PrePassword",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetNewPassword()) < 1 {
		err := ChangePasswordByPreRequestValidationError{
			field:  "NewPassword",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetConfirmNewPassword()) < 1 {
		err := ChangePasswordByPreRequestValidationError{
			field:  "ConfirmNewPassword",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ChangePasswordByPreRequestMultiError(errors)
	}

	return nil
}

// ChangePasswordByPreRequestMultiError is an error wrapping multiple
// validation errors returned by ChangePasswordByPreRequest.ValidateAll() if
// the designated constraints aren't met.
type ChangePasswordByPreRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangePasswordByPreRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangePasswordByPreRequestMultiError) AllErrors() []error { return m }

// ChangePasswordByPreRequestValidationError is the validation error returned
// by ChangePasswordByPreRequest.Validate if the designated constraints aren't met.
type ChangePasswordByPreRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangePasswordByPreRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangePasswordByPreRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangePasswordByPreRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangePasswordByPreRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangePasswordByPreRequestValidationError) ErrorName() string {
	return "ChangePasswordByPreRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ChangePasswordByPreRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangePasswordByPreRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangePasswordByPreRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangePasswordByPreRequestValidationError{}

// Validate checks the field values on ChangePasswordByPreReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ChangePasswordByPreReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangePasswordByPreReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ChangePasswordByPreReplyMultiError, or nil if none found.
func (m *ChangePasswordByPreReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangePasswordByPreReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ChangePasswordByPreReplyMultiError(errors)
	}

	return nil
}

// ChangePasswordByPreReplyMultiError is an error wrapping multiple validation
// errors returned by ChangePasswordByPreReply.ValidateAll() if the designated
// constraints aren't met.
type ChangePasswordByPreReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangePasswordByPreReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangePasswordByPreReplyMultiError) AllErrors() []error { return m }

// ChangePasswordByPreReplyValidationError is the validation error returned by
// ChangePasswordByPreReply.Validate if the designated constraints aren't met.
type ChangePasswordByPreReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangePasswordByPreReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangePasswordByPreReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangePasswordByPreReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangePasswordByPreReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangePasswordByPreReplyValidationError) ErrorName() string {
	return "ChangePasswordByPreReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ChangePasswordByPreReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangePasswordByPreReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangePasswordByPreReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangePasswordByPreReplyValidationError{}

// Validate checks the field values on RefreshRememberTokenRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshRememberTokenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshRememberTokenRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshRememberTokenRequestMultiError, or nil if none found.
func (m *RefreshRememberTokenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshRememberTokenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RmToken

	if len(errors) > 0 {
		return RefreshRememberTokenRequestMultiError(errors)
	}

	return nil
}

// RefreshRememberTokenRequestMultiError is an error wrapping multiple
// validation errors returned by RefreshRememberTokenRequest.ValidateAll() if
// the designated constraints aren't met.
type RefreshRememberTokenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshRememberTokenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshRememberTokenRequestMultiError) AllErrors() []error { return m }

// RefreshRememberTokenRequestValidationError is the validation error returned
// by RefreshRememberTokenRequest.Validate if the designated constraints
// aren't met.
type RefreshRememberTokenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshRememberTokenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshRememberTokenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshRememberTokenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshRememberTokenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshRememberTokenRequestValidationError) ErrorName() string {
	return "RefreshRememberTokenRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshRememberTokenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshRememberTokenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshRememberTokenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshRememberTokenRequestValidationError{}

// Validate checks the field values on RefreshRememberTokenReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RefreshRememberTokenReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshRememberTokenReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RefreshRememberTokenReplyMultiError, or nil if none found.
func (m *RefreshRememberTokenReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshRememberTokenReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	// no validation rules for NewRmToken

	if len(errors) > 0 {
		return RefreshRememberTokenReplyMultiError(errors)
	}

	return nil
}

// RefreshRememberTokenReplyMultiError is an error wrapping multiple validation
// errors returned by RefreshRememberTokenReply.ValidateAll() if the
// designated constraints aren't met.
type RefreshRememberTokenReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshRememberTokenReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshRememberTokenReplyMultiError) AllErrors() []error { return m }

// RefreshRememberTokenReplyValidationError is the validation error returned by
// RefreshRememberTokenReply.Validate if the designated constraints aren't met.
type RefreshRememberTokenReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshRememberTokenReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshRememberTokenReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshRememberTokenReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshRememberTokenReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshRememberTokenReplyValidationError) ErrorName() string {
	return "RefreshRememberTokenReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RefreshRememberTokenReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshRememberTokenReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshRememberTokenReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshRememberTokenReplyValidationError{}
