// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             (unknown)
// source: google/api/serviceusage/v1/serviceusage.proto

package serviceusagepb

import (
	longrunningpb "cloud.google.com/go/longrunning/autogen/longrunningpb"
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationServiceUsageBatchEnableServices = "/google.api.serviceusage.v1.ServiceUsage/BatchEnableServices"
const OperationServiceUsageBatchGetServices = "/google.api.serviceusage.v1.ServiceUsage/BatchGetServices"
const OperationServiceUsageDisableService = "/google.api.serviceusage.v1.ServiceUsage/DisableService"
const OperationServiceUsageEnableService = "/google.api.serviceusage.v1.ServiceUsage/EnableService"
const OperationServiceUsageGetService = "/google.api.serviceusage.v1.ServiceUsage/GetService"
const OperationServiceUsageListServices = "/google.api.serviceusage.v1.ServiceUsage/ListServices"

type ServiceUsageHTTPServer interface {
	// BatchEnableServices Enable multiple services on a project. The operation is atomic: if enabling
	// any service fails, then the entire batch fails, and no state changes occur.
	// To enable a single service, use the `EnableService` method instead.
	BatchEnableServices(context.Context, *BatchEnableServicesRequest) (*longrunningpb.Operation, error)
	// BatchGetServices Returns the service configurations and enabled states for a given list of
	// services.
	BatchGetServices(context.Context, *BatchGetServicesRequest) (*BatchGetServicesResponse, error)
	// DisableService Disable a service so that it can no longer be used with a project.
	// This prevents unintended usage that may cause unexpected billing
	// charges or security leaks.
	//
	// It is not valid to call the disable method on a service that is not
	// currently enabled. Callers will receive a `FAILED_PRECONDITION` status if
	// the target service is not currently enabled.
	DisableService(context.Context, *DisableServiceRequest) (*longrunningpb.Operation, error)
	// EnableService Enable a service so that it can be used with a project.
	EnableService(context.Context, *EnableServiceRequest) (*longrunningpb.Operation, error)
	// GetService Returns the service configuration and enabled state for a given service.
	GetService(context.Context, *GetServiceRequest) (*Service, error)
	// ListServices List all services available to the specified project, and the current
	// state of those services with respect to the project. The list includes
	// all public services, all services for which the calling user has the
	// `servicemanagement.services.bind` permission, and all services that have
	// already been enabled on the project. The list can be filtered to
	// only include services in a specific state, for example to only include
	// services enabled on the project.
	//
	// WARNING: If you need to query enabled services frequently or across
	// an organization, you should use
	// [Cloud Asset Inventory
	// API](https://cloud.google.com/asset-inventory/docs/apis), which provides
	// higher throughput and richer filtering capability.
	ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error)
}

func RegisterServiceUsageHTTPServer(s *http.Server, srv ServiceUsageHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/{name:.*/.*/services/.*}:enable", _ServiceUsage_EnableService0_HTTP_Handler(srv))
	r.POST("/v1/{name:.*/.*/services/.*}:disable", _ServiceUsage_DisableService0_HTTP_Handler(srv))
	r.GET("/v1/{name:.*/.*/services/.*}", _ServiceUsage_GetService0_HTTP_Handler(srv))
	r.GET("/v1/{parent:.*/.*}/services", _ServiceUsage_ListServices0_HTTP_Handler(srv))
	r.POST("/v1/{parent:.*/.*}/services:batchEnable", _ServiceUsage_BatchEnableServices0_HTTP_Handler(srv))
	r.GET("/v1/{parent:.*/.*}/services:batchGet", _ServiceUsage_BatchGetServices0_HTTP_Handler(srv))
}

func _ServiceUsage_EnableService0_HTTP_Handler(srv ServiceUsageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in EnableServiceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationServiceUsageEnableService)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.EnableService(ctx, req.(*EnableServiceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*longrunningpb.Operation)
		return ctx.Result(200, reply)
	}
}

func _ServiceUsage_DisableService0_HTTP_Handler(srv ServiceUsageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DisableServiceRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationServiceUsageDisableService)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DisableService(ctx, req.(*DisableServiceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*longrunningpb.Operation)
		return ctx.Result(200, reply)
	}
}

func _ServiceUsage_GetService0_HTTP_Handler(srv ServiceUsageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetServiceRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationServiceUsageGetService)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetService(ctx, req.(*GetServiceRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Service)
		return ctx.Result(200, reply)
	}
}

func _ServiceUsage_ListServices0_HTTP_Handler(srv ServiceUsageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListServicesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationServiceUsageListServices)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListServices(ctx, req.(*ListServicesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListServicesResponse)
		return ctx.Result(200, reply)
	}
}

func _ServiceUsage_BatchEnableServices0_HTTP_Handler(srv ServiceUsageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BatchEnableServicesRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationServiceUsageBatchEnableServices)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchEnableServices(ctx, req.(*BatchEnableServicesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*longrunningpb.Operation)
		return ctx.Result(200, reply)
	}
}

func _ServiceUsage_BatchGetServices0_HTTP_Handler(srv ServiceUsageHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in BatchGetServicesRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationServiceUsageBatchGetServices)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.BatchGetServices(ctx, req.(*BatchGetServicesRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*BatchGetServicesResponse)
		return ctx.Result(200, reply)
	}
}

type ServiceUsageHTTPClient interface {
	BatchEnableServices(ctx context.Context, req *BatchEnableServicesRequest, opts ...http.CallOption) (rsp *longrunningpb.Operation, err error)
	BatchGetServices(ctx context.Context, req *BatchGetServicesRequest, opts ...http.CallOption) (rsp *BatchGetServicesResponse, err error)
	DisableService(ctx context.Context, req *DisableServiceRequest, opts ...http.CallOption) (rsp *longrunningpb.Operation, err error)
	EnableService(ctx context.Context, req *EnableServiceRequest, opts ...http.CallOption) (rsp *longrunningpb.Operation, err error)
	GetService(ctx context.Context, req *GetServiceRequest, opts ...http.CallOption) (rsp *Service, err error)
	ListServices(ctx context.Context, req *ListServicesRequest, opts ...http.CallOption) (rsp *ListServicesResponse, err error)
}

type ServiceUsageHTTPClientImpl struct {
	cc *http.Client
}

func NewServiceUsageHTTPClient(client *http.Client) ServiceUsageHTTPClient {
	return &ServiceUsageHTTPClientImpl{client}
}

func (c *ServiceUsageHTTPClientImpl) BatchEnableServices(ctx context.Context, in *BatchEnableServicesRequest, opts ...http.CallOption) (*longrunningpb.Operation, error) {
	var out longrunningpb.Operation
	pattern := "/v1/{parent:.*/.*}/services:batchEnable"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationServiceUsageBatchEnableServices))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ServiceUsageHTTPClientImpl) BatchGetServices(ctx context.Context, in *BatchGetServicesRequest, opts ...http.CallOption) (*BatchGetServicesResponse, error) {
	var out BatchGetServicesResponse
	pattern := "/v1/{parent:.*/.*}/services:batchGet"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationServiceUsageBatchGetServices))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ServiceUsageHTTPClientImpl) DisableService(ctx context.Context, in *DisableServiceRequest, opts ...http.CallOption) (*longrunningpb.Operation, error) {
	var out longrunningpb.Operation
	pattern := "/v1/{name:.*/.*/services/.*}:disable"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationServiceUsageDisableService))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ServiceUsageHTTPClientImpl) EnableService(ctx context.Context, in *EnableServiceRequest, opts ...http.CallOption) (*longrunningpb.Operation, error) {
	var out longrunningpb.Operation
	pattern := "/v1/{name:.*/.*/services/.*}:enable"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationServiceUsageEnableService))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ServiceUsageHTTPClientImpl) GetService(ctx context.Context, in *GetServiceRequest, opts ...http.CallOption) (*Service, error) {
	var out Service
	pattern := "/v1/{name:.*/.*/services/.*}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationServiceUsageGetService))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ServiceUsageHTTPClientImpl) ListServices(ctx context.Context, in *ListServicesRequest, opts ...http.CallOption) (*ListServicesResponse, error) {
	var out ListServicesResponse
	pattern := "/v1/{parent:.*/.*}/services"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationServiceUsageListServices))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
