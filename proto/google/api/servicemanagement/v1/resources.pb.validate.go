// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: google/api/servicemanagement/v1/resources.proto

package servicemanagementpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ManagedService with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ManagedService) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ManagedService with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ManagedServiceMultiError,
// or nil if none found.
func (m *ManagedService) ValidateAll() error {
	return m.validate(true)
}

func (m *ManagedService) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ServiceName

	// no validation rules for ProducerProjectId

	if len(errors) > 0 {
		return ManagedServiceMultiError(errors)
	}

	return nil
}

// ManagedServiceMultiError is an error wrapping multiple validation errors
// returned by ManagedService.ValidateAll() if the designated constraints
// aren't met.
type ManagedServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ManagedServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ManagedServiceMultiError) AllErrors() []error { return m }

// ManagedServiceValidationError is the validation error returned by
// ManagedService.Validate if the designated constraints aren't met.
type ManagedServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ManagedServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ManagedServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ManagedServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ManagedServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ManagedServiceValidationError) ErrorName() string { return "ManagedServiceValidationError" }

// Error satisfies the builtin error interface
func (e ManagedServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sManagedService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ManagedServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ManagedServiceValidationError{}

// Validate checks the field values on OperationMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OperationMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationMetadataMultiError, or nil if none found.
func (m *OperationMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSteps() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OperationMetadataValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OperationMetadataValidationError{
						field:  fmt.Sprintf("Steps[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OperationMetadataValidationError{
					field:  fmt.Sprintf("Steps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ProgressPercentage

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OperationMetadataValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OperationMetadataValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OperationMetadataValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OperationMetadataMultiError(errors)
	}

	return nil
}

// OperationMetadataMultiError is an error wrapping multiple validation errors
// returned by OperationMetadata.ValidateAll() if the designated constraints
// aren't met.
type OperationMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationMetadataMultiError) AllErrors() []error { return m }

// OperationMetadataValidationError is the validation error returned by
// OperationMetadata.Validate if the designated constraints aren't met.
type OperationMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationMetadataValidationError) ErrorName() string {
	return "OperationMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e OperationMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationMetadataValidationError{}

// Validate checks the field values on Diagnostic with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Diagnostic) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Diagnostic with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DiagnosticMultiError, or
// nil if none found.
func (m *Diagnostic) ValidateAll() error {
	return m.validate(true)
}

func (m *Diagnostic) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Location

	// no validation rules for Kind

	// no validation rules for Message

	if len(errors) > 0 {
		return DiagnosticMultiError(errors)
	}

	return nil
}

// DiagnosticMultiError is an error wrapping multiple validation errors
// returned by Diagnostic.ValidateAll() if the designated constraints aren't met.
type DiagnosticMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiagnosticMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiagnosticMultiError) AllErrors() []error { return m }

// DiagnosticValidationError is the validation error returned by
// Diagnostic.Validate if the designated constraints aren't met.
type DiagnosticValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiagnosticValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiagnosticValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiagnosticValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiagnosticValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiagnosticValidationError) ErrorName() string { return "DiagnosticValidationError" }

// Error satisfies the builtin error interface
func (e DiagnosticValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiagnostic.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiagnosticValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiagnosticValidationError{}

// Validate checks the field values on ConfigSource with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigSource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigSourceMultiError, or
// nil if none found.
func (m *ConfigSource) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ConfigSourceValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ConfigSourceValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ConfigSourceValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ConfigSourceMultiError(errors)
	}

	return nil
}

// ConfigSourceMultiError is an error wrapping multiple validation errors
// returned by ConfigSource.ValidateAll() if the designated constraints aren't met.
type ConfigSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigSourceMultiError) AllErrors() []error { return m }

// ConfigSourceValidationError is the validation error returned by
// ConfigSource.Validate if the designated constraints aren't met.
type ConfigSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigSourceValidationError) ErrorName() string { return "ConfigSourceValidationError" }

// Error satisfies the builtin error interface
func (e ConfigSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigSourceValidationError{}

// Validate checks the field values on ConfigFile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigFile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigFile with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigFileMultiError, or
// nil if none found.
func (m *ConfigFile) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigFile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FilePath

	// no validation rules for FileContents

	// no validation rules for FileType

	if len(errors) > 0 {
		return ConfigFileMultiError(errors)
	}

	return nil
}

// ConfigFileMultiError is an error wrapping multiple validation errors
// returned by ConfigFile.ValidateAll() if the designated constraints aren't met.
type ConfigFileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigFileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigFileMultiError) AllErrors() []error { return m }

// ConfigFileValidationError is the validation error returned by
// ConfigFile.Validate if the designated constraints aren't met.
type ConfigFileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigFileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigFileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigFileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigFileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigFileValidationError) ErrorName() string { return "ConfigFileValidationError" }

// Error satisfies the builtin error interface
func (e ConfigFileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigFileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigFileValidationError{}

// Validate checks the field values on ConfigRef with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigRef) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigRef with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigRefMultiError, or nil
// if none found.
func (m *ConfigRef) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigRef) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ConfigRefMultiError(errors)
	}

	return nil
}

// ConfigRefMultiError is an error wrapping multiple validation errors returned
// by ConfigRef.ValidateAll() if the designated constraints aren't met.
type ConfigRefMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigRefMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigRefMultiError) AllErrors() []error { return m }

// ConfigRefValidationError is the validation error returned by
// ConfigRef.Validate if the designated constraints aren't met.
type ConfigRefValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigRefValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigRefValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigRefValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigRefValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigRefValidationError) ErrorName() string { return "ConfigRefValidationError" }

// Error satisfies the builtin error interface
func (e ConfigRefValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigRef.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigRefValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigRefValidationError{}

// Validate checks the field values on ChangeReport with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ChangeReport) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ChangeReport with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ChangeReportMultiError, or
// nil if none found.
func (m *ChangeReport) ValidateAll() error {
	return m.validate(true)
}

func (m *ChangeReport) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConfigChanges() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ChangeReportValidationError{
						field:  fmt.Sprintf("ConfigChanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ChangeReportValidationError{
						field:  fmt.Sprintf("ConfigChanges[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ChangeReportValidationError{
					field:  fmt.Sprintf("ConfigChanges[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ChangeReportMultiError(errors)
	}

	return nil
}

// ChangeReportMultiError is an error wrapping multiple validation errors
// returned by ChangeReport.ValidateAll() if the designated constraints aren't met.
type ChangeReportMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ChangeReportMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ChangeReportMultiError) AllErrors() []error { return m }

// ChangeReportValidationError is the validation error returned by
// ChangeReport.Validate if the designated constraints aren't met.
type ChangeReportValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ChangeReportValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ChangeReportValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ChangeReportValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ChangeReportValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ChangeReportValidationError) ErrorName() string { return "ChangeReportValidationError" }

// Error satisfies the builtin error interface
func (e ChangeReportValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sChangeReport.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ChangeReportValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ChangeReportValidationError{}

// Validate checks the field values on Rollout with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Rollout) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rollout with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RolloutMultiError, or nil if none found.
func (m *Rollout) ValidateAll() error {
	return m.validate(true)
}

func (m *Rollout) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RolloutId

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RolloutValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RolloutValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RolloutValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CreatedBy

	// no validation rules for Status

	// no validation rules for ServiceName

	switch v := m.Strategy.(type) {
	case *Rollout_TrafficPercentStrategy_:
		if v == nil {
			err := RolloutValidationError{
				field:  "Strategy",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrafficPercentStrategy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RolloutValidationError{
						field:  "TrafficPercentStrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RolloutValidationError{
						field:  "TrafficPercentStrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrafficPercentStrategy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RolloutValidationError{
					field:  "TrafficPercentStrategy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Rollout_DeleteServiceStrategy_:
		if v == nil {
			err := RolloutValidationError{
				field:  "Strategy",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeleteServiceStrategy()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RolloutValidationError{
						field:  "DeleteServiceStrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RolloutValidationError{
						field:  "DeleteServiceStrategy",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeleteServiceStrategy()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RolloutValidationError{
					field:  "DeleteServiceStrategy",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RolloutMultiError(errors)
	}

	return nil
}

// RolloutMultiError is an error wrapping multiple validation errors returned
// by Rollout.ValidateAll() if the designated constraints aren't met.
type RolloutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RolloutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RolloutMultiError) AllErrors() []error { return m }

// RolloutValidationError is the validation error returned by Rollout.Validate
// if the designated constraints aren't met.
type RolloutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RolloutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RolloutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RolloutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RolloutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RolloutValidationError) ErrorName() string { return "RolloutValidationError" }

// Error satisfies the builtin error interface
func (e RolloutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollout.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RolloutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RolloutValidationError{}

// Validate checks the field values on OperationMetadata_Step with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *OperationMetadata_Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OperationMetadata_Step with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OperationMetadata_StepMultiError, or nil if none found.
func (m *OperationMetadata_Step) ValidateAll() error {
	return m.validate(true)
}

func (m *OperationMetadata_Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Description

	// no validation rules for Status

	if len(errors) > 0 {
		return OperationMetadata_StepMultiError(errors)
	}

	return nil
}

// OperationMetadata_StepMultiError is an error wrapping multiple validation
// errors returned by OperationMetadata_Step.ValidateAll() if the designated
// constraints aren't met.
type OperationMetadata_StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OperationMetadata_StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OperationMetadata_StepMultiError) AllErrors() []error { return m }

// OperationMetadata_StepValidationError is the validation error returned by
// OperationMetadata_Step.Validate if the designated constraints aren't met.
type OperationMetadata_StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OperationMetadata_StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OperationMetadata_StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OperationMetadata_StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OperationMetadata_StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OperationMetadata_StepValidationError) ErrorName() string {
	return "OperationMetadata_StepValidationError"
}

// Error satisfies the builtin error interface
func (e OperationMetadata_StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOperationMetadata_Step.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OperationMetadata_StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OperationMetadata_StepValidationError{}

// Validate checks the field values on Rollout_TrafficPercentStrategy with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Rollout_TrafficPercentStrategy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rollout_TrafficPercentStrategy with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Rollout_TrafficPercentStrategyMultiError, or nil if none found.
func (m *Rollout_TrafficPercentStrategy) ValidateAll() error {
	return m.validate(true)
}

func (m *Rollout_TrafficPercentStrategy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Percentages

	if len(errors) > 0 {
		return Rollout_TrafficPercentStrategyMultiError(errors)
	}

	return nil
}

// Rollout_TrafficPercentStrategyMultiError is an error wrapping multiple
// validation errors returned by Rollout_TrafficPercentStrategy.ValidateAll()
// if the designated constraints aren't met.
type Rollout_TrafficPercentStrategyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Rollout_TrafficPercentStrategyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Rollout_TrafficPercentStrategyMultiError) AllErrors() []error { return m }

// Rollout_TrafficPercentStrategyValidationError is the validation error
// returned by Rollout_TrafficPercentStrategy.Validate if the designated
// constraints aren't met.
type Rollout_TrafficPercentStrategyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Rollout_TrafficPercentStrategyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Rollout_TrafficPercentStrategyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Rollout_TrafficPercentStrategyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Rollout_TrafficPercentStrategyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Rollout_TrafficPercentStrategyValidationError) ErrorName() string {
	return "Rollout_TrafficPercentStrategyValidationError"
}

// Error satisfies the builtin error interface
func (e Rollout_TrafficPercentStrategyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollout_TrafficPercentStrategy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Rollout_TrafficPercentStrategyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Rollout_TrafficPercentStrategyValidationError{}

// Validate checks the field values on Rollout_DeleteServiceStrategy with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Rollout_DeleteServiceStrategy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rollout_DeleteServiceStrategy with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Rollout_DeleteServiceStrategyMultiError, or nil if none found.
func (m *Rollout_DeleteServiceStrategy) ValidateAll() error {
	return m.validate(true)
}

func (m *Rollout_DeleteServiceStrategy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Rollout_DeleteServiceStrategyMultiError(errors)
	}

	return nil
}

// Rollout_DeleteServiceStrategyMultiError is an error wrapping multiple
// validation errors returned by Rollout_DeleteServiceStrategy.ValidateAll()
// if the designated constraints aren't met.
type Rollout_DeleteServiceStrategyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Rollout_DeleteServiceStrategyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Rollout_DeleteServiceStrategyMultiError) AllErrors() []error { return m }

// Rollout_DeleteServiceStrategyValidationError is the validation error
// returned by Rollout_DeleteServiceStrategy.Validate if the designated
// constraints aren't met.
type Rollout_DeleteServiceStrategyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Rollout_DeleteServiceStrategyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Rollout_DeleteServiceStrategyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Rollout_DeleteServiceStrategyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Rollout_DeleteServiceStrategyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Rollout_DeleteServiceStrategyValidationError) ErrorName() string {
	return "Rollout_DeleteServiceStrategyValidationError"
}

// Error satisfies the builtin error interface
func (e Rollout_DeleteServiceStrategyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRollout_DeleteServiceStrategy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Rollout_DeleteServiceStrategyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Rollout_DeleteServiceStrategyValidationError{}
