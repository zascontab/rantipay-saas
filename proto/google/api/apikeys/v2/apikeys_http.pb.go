// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             (unknown)
// source: google/api/apikeys/v2/apikeys.proto

package apikeyspb

import (
	longrunningpb "cloud.google.com/go/longrunning/autogen/longrunningpb"
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationApiKeysCreateKey = "/google.api.apikeys.v2.ApiKeys/CreateKey"
const OperationApiKeysDeleteKey = "/google.api.apikeys.v2.ApiKeys/DeleteKey"
const OperationApiKeysGetKey = "/google.api.apikeys.v2.ApiKeys/GetKey"
const OperationApiKeysGetKeyString = "/google.api.apikeys.v2.ApiKeys/GetKeyString"
const OperationApiKeysListKeys = "/google.api.apikeys.v2.ApiKeys/ListKeys"
const OperationApiKeysLookupKey = "/google.api.apikeys.v2.ApiKeys/LookupKey"
const OperationApiKeysUndeleteKey = "/google.api.apikeys.v2.ApiKeys/UndeleteKey"
const OperationApiKeysUpdateKey = "/google.api.apikeys.v2.ApiKeys/UpdateKey"

type ApiKeysHTTPServer interface {
	// CreateKey Creates a new API key.
	//
	// NOTE: Key is a global resource; hence the only supported value for
	// location is `global`.
	CreateKey(context.Context, *CreateKeyRequest) (*longrunningpb.Operation, error)
	// DeleteKey Deletes an API key. Deleted key can be retrieved within 30 days of
	// deletion. Afterward, key will be purged from the project.
	//
	// NOTE: Key is a global resource; hence the only supported value for
	// location is `global`.
	DeleteKey(context.Context, *DeleteKeyRequest) (*longrunningpb.Operation, error)
	// GetKey Gets the metadata for an API key. The key string of the API key
	// isn't included in the response.
	//
	// NOTE: Key is a global resource; hence the only supported value for
	// location is `global`.
	GetKey(context.Context, *GetKeyRequest) (*Key, error)
	// GetKeyString Get the key string for an API key.
	//
	// NOTE: Key is a global resource; hence the only supported value for
	// location is `global`.
	GetKeyString(context.Context, *GetKeyStringRequest) (*GetKeyStringResponse, error)
	// ListKeys Lists the API keys owned by a project. The key string of the API key
	// isn't included in the response.
	//
	// NOTE: Key is a global resource; hence the only supported value for
	// location is `global`.
	ListKeys(context.Context, *ListKeysRequest) (*ListKeysResponse, error)
	// LookupKey Find the parent project and resource name of the API
	// key that matches the key string in the request. If the API key has been
	// purged, resource name will not be set.
	// The service account must have the `apikeys.keys.lookup` permission
	// on the parent project.
	LookupKey(context.Context, *LookupKeyRequest) (*LookupKeyResponse, error)
	// UndeleteKey Undeletes an API key which was deleted within 30 days.
	//
	// NOTE: Key is a global resource; hence the only supported value for
	// location is `global`.
	UndeleteKey(context.Context, *UndeleteKeyRequest) (*longrunningpb.Operation, error)
	// UpdateKey Patches the modifiable fields of an API key.
	// The key string of the API key isn't included in the response.
	//
	// NOTE: Key is a global resource; hence the only supported value for
	// location is `global`.
	UpdateKey(context.Context, *UpdateKeyRequest) (*longrunningpb.Operation, error)
}

func RegisterApiKeysHTTPServer(s *http.Server, srv ApiKeysHTTPServer) {
	r := s.Route("/")
	r.POST("/v2/{parent:projects/.*/locations/.*}/keys", _ApiKeys_CreateKey0_HTTP_Handler(srv))
	r.GET("/v2/{parent:projects/.*/locations/.*}/keys", _ApiKeys_ListKeys0_HTTP_Handler(srv))
	r.GET("/v2/{name:projects/.*/locations/.*/keys/.*}", _ApiKeys_GetKey0_HTTP_Handler(srv))
	r.GET("/v2/{name:projects/.*/locations/.*/keys/.*}/keyString", _ApiKeys_GetKeyString0_HTTP_Handler(srv))
	r.PATCH("/v2/{key.name:projects/.*/locations/.*/keys/.*}", _ApiKeys_UpdateKey0_HTTP_Handler(srv))
	r.DELETE("/v2/{name:projects/.*/locations/.*/keys/.*}", _ApiKeys_DeleteKey0_HTTP_Handler(srv))
	r.POST("/v2/{name:projects/.*/locations/.*/keys/.*}:undelete", _ApiKeys_UndeleteKey0_HTTP_Handler(srv))
	r.GET("/v2/keys:lookupKey", _ApiKeys_LookupKey0_HTTP_Handler(srv))
}

func _ApiKeys_CreateKey0_HTTP_Handler(srv ApiKeysHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateKeyRequest
		if err := ctx.Bind(&in.Key); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationApiKeysCreateKey)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateKey(ctx, req.(*CreateKeyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*longrunningpb.Operation)
		return ctx.Result(200, reply)
	}
}

func _ApiKeys_ListKeys0_HTTP_Handler(srv ApiKeysHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListKeysRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationApiKeysListKeys)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListKeys(ctx, req.(*ListKeysRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListKeysResponse)
		return ctx.Result(200, reply)
	}
}

func _ApiKeys_GetKey0_HTTP_Handler(srv ApiKeysHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetKeyRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationApiKeysGetKey)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetKey(ctx, req.(*GetKeyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*Key)
		return ctx.Result(200, reply)
	}
}

func _ApiKeys_GetKeyString0_HTTP_Handler(srv ApiKeysHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetKeyStringRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationApiKeysGetKeyString)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetKeyString(ctx, req.(*GetKeyStringRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*GetKeyStringResponse)
		return ctx.Result(200, reply)
	}
}

func _ApiKeys_UpdateKey0_HTTP_Handler(srv ApiKeysHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateKeyRequest
		if err := ctx.Bind(&in.Key); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationApiKeysUpdateKey)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateKey(ctx, req.(*UpdateKeyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*longrunningpb.Operation)
		return ctx.Result(200, reply)
	}
}

func _ApiKeys_DeleteKey0_HTTP_Handler(srv ApiKeysHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteKeyRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationApiKeysDeleteKey)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteKey(ctx, req.(*DeleteKeyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*longrunningpb.Operation)
		return ctx.Result(200, reply)
	}
}

func _ApiKeys_UndeleteKey0_HTTP_Handler(srv ApiKeysHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UndeleteKeyRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationApiKeysUndeleteKey)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UndeleteKey(ctx, req.(*UndeleteKeyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*longrunningpb.Operation)
		return ctx.Result(200, reply)
	}
}

func _ApiKeys_LookupKey0_HTTP_Handler(srv ApiKeysHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in LookupKeyRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationApiKeysLookupKey)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.LookupKey(ctx, req.(*LookupKeyRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*LookupKeyResponse)
		return ctx.Result(200, reply)
	}
}

type ApiKeysHTTPClient interface {
	CreateKey(ctx context.Context, req *CreateKeyRequest, opts ...http.CallOption) (rsp *longrunningpb.Operation, err error)
	DeleteKey(ctx context.Context, req *DeleteKeyRequest, opts ...http.CallOption) (rsp *longrunningpb.Operation, err error)
	GetKey(ctx context.Context, req *GetKeyRequest, opts ...http.CallOption) (rsp *Key, err error)
	GetKeyString(ctx context.Context, req *GetKeyStringRequest, opts ...http.CallOption) (rsp *GetKeyStringResponse, err error)
	ListKeys(ctx context.Context, req *ListKeysRequest, opts ...http.CallOption) (rsp *ListKeysResponse, err error)
	LookupKey(ctx context.Context, req *LookupKeyRequest, opts ...http.CallOption) (rsp *LookupKeyResponse, err error)
	UndeleteKey(ctx context.Context, req *UndeleteKeyRequest, opts ...http.CallOption) (rsp *longrunningpb.Operation, err error)
	UpdateKey(ctx context.Context, req *UpdateKeyRequest, opts ...http.CallOption) (rsp *longrunningpb.Operation, err error)
}

type ApiKeysHTTPClientImpl struct {
	cc *http.Client
}

func NewApiKeysHTTPClient(client *http.Client) ApiKeysHTTPClient {
	return &ApiKeysHTTPClientImpl{client}
}

func (c *ApiKeysHTTPClientImpl) CreateKey(ctx context.Context, in *CreateKeyRequest, opts ...http.CallOption) (*longrunningpb.Operation, error) {
	var out longrunningpb.Operation
	pattern := "/v2/{parent:projects/.*/locations/.*}/keys"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationApiKeysCreateKey))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in.Key, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ApiKeysHTTPClientImpl) DeleteKey(ctx context.Context, in *DeleteKeyRequest, opts ...http.CallOption) (*longrunningpb.Operation, error) {
	var out longrunningpb.Operation
	pattern := "/v2/{name:projects/.*/locations/.*/keys/.*}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationApiKeysDeleteKey))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ApiKeysHTTPClientImpl) GetKey(ctx context.Context, in *GetKeyRequest, opts ...http.CallOption) (*Key, error) {
	var out Key
	pattern := "/v2/{name:projects/.*/locations/.*/keys/.*}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationApiKeysGetKey))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ApiKeysHTTPClientImpl) GetKeyString(ctx context.Context, in *GetKeyStringRequest, opts ...http.CallOption) (*GetKeyStringResponse, error) {
	var out GetKeyStringResponse
	pattern := "/v2/{name:projects/.*/locations/.*/keys/.*}/keyString"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationApiKeysGetKeyString))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ApiKeysHTTPClientImpl) ListKeys(ctx context.Context, in *ListKeysRequest, opts ...http.CallOption) (*ListKeysResponse, error) {
	var out ListKeysResponse
	pattern := "/v2/{parent:projects/.*/locations/.*}/keys"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationApiKeysListKeys))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ApiKeysHTTPClientImpl) LookupKey(ctx context.Context, in *LookupKeyRequest, opts ...http.CallOption) (*LookupKeyResponse, error) {
	var out LookupKeyResponse
	pattern := "/v2/keys:lookupKey"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationApiKeysLookupKey))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ApiKeysHTTPClientImpl) UndeleteKey(ctx context.Context, in *UndeleteKeyRequest, opts ...http.CallOption) (*longrunningpb.Operation, error) {
	var out longrunningpb.Operation
	pattern := "/v2/{name:projects/.*/locations/.*/keys/.*}:undelete"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationApiKeysUndeleteKey))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *ApiKeysHTTPClientImpl) UpdateKey(ctx context.Context, in *UpdateKeyRequest, opts ...http.CallOption) (*longrunningpb.Operation, error) {
	var out longrunningpb.Operation
	pattern := "/v2/{key.name:projects/.*/locations/.*/keys/.*}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationApiKeysUpdateKey))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PATCH", path, in.Key, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
