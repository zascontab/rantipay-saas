// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: payment/api/subscription/v1/subscription.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSubscriptionRequestMultiError, or nil if none found.
func (m *CreateSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UserId

	if _, ok := _CreateSubscriptionRequest_Provider_InLookup[m.GetProvider()]; !ok {
		err := CreateSubscriptionRequestValidationError{
			field:  "Provider",
			reason: "value must be in list [stripe]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateSubscriptionRequestValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateSubscriptionRequestValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateSubscriptionRequestValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateSubscriptionRequestMultiError(errors)
	}

	return nil
}

// CreateSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSubscriptionRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSubscriptionRequestMultiError) AllErrors() []error { return m }

// CreateSubscriptionRequestValidationError is the validation error returned by
// CreateSubscriptionRequest.Validate if the designated constraints aren't met.
type CreateSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSubscriptionRequestValidationError) ErrorName() string {
	return "CreateSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSubscriptionRequestValidationError{}

var _CreateSubscriptionRequest_Provider_InLookup = map[string]struct{}{
	"stripe": {},
}

// Validate checks the field values on Subscription with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Subscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Subscription with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SubscriptionMultiError, or
// nil if none found.
func (m *Subscription) ValidateAll() error {
	return m.validate(true)
}

func (m *Subscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for UserId

	if all {
		switch v := interface{}(m.GetUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionValidationError{
					field:  "User",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionValidationError{
				field:  "User",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Provider

	// no validation rules for ProviderKey

	// no validation rules for Status

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscriptionValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscriptionValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscriptionValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetProviderInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionValidationError{
					field:  "ProviderInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionValidationError{
					field:  "ProviderInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProviderInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionValidationError{
				field:  "ProviderInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubscriptionMultiError(errors)
	}

	return nil
}

// SubscriptionMultiError is an error wrapping multiple validation errors
// returned by Subscription.ValidateAll() if the designated constraints aren't met.
type SubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionMultiError) AllErrors() []error { return m }

// SubscriptionValidationError is the validation error returned by
// Subscription.Validate if the designated constraints aren't met.
type SubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionValidationError) ErrorName() string { return "SubscriptionValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionValidationError{}

// Validate checks the field values on SubscriptionProviderInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionProviderInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionProviderInfo with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionProviderInfoMultiError, or nil if none found.
func (m *SubscriptionProviderInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionProviderInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStripe()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionProviderInfoValidationError{
					field:  "Stripe",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionProviderInfoValidationError{
					field:  "Stripe",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStripe()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionProviderInfoValidationError{
				field:  "Stripe",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubscriptionProviderInfoMultiError(errors)
	}

	return nil
}

// SubscriptionProviderInfoMultiError is an error wrapping multiple validation
// errors returned by SubscriptionProviderInfo.ValidateAll() if the designated
// constraints aren't met.
type SubscriptionProviderInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionProviderInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionProviderInfoMultiError) AllErrors() []error { return m }

// SubscriptionProviderInfoValidationError is the validation error returned by
// SubscriptionProviderInfo.Validate if the designated constraints aren't met.
type SubscriptionProviderInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionProviderInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionProviderInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionProviderInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionProviderInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionProviderInfoValidationError) ErrorName() string {
	return "SubscriptionProviderInfoValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionProviderInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionProviderInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionProviderInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionProviderInfoValidationError{}

// Validate checks the field values on SubscriptionStripeInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionStripeInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionStripeInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionStripeInfoMultiError, or nil if none found.
func (m *SubscriptionStripeInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionStripeInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSubscription()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionStripeInfoValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionStripeInfoValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscription()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionStripeInfoValidationError{
				field:  "Subscription",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubscriptionStripeInfoMultiError(errors)
	}

	return nil
}

// SubscriptionStripeInfoMultiError is an error wrapping multiple validation
// errors returned by SubscriptionStripeInfo.ValidateAll() if the designated
// constraints aren't met.
type SubscriptionStripeInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionStripeInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionStripeInfoMultiError) AllErrors() []error { return m }

// SubscriptionStripeInfoValidationError is the validation error returned by
// SubscriptionStripeInfo.Validate if the designated constraints aren't met.
type SubscriptionStripeInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionStripeInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionStripeInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionStripeInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionStripeInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionStripeInfoValidationError) ErrorName() string {
	return "SubscriptionStripeInfoValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionStripeInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionStripeInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionStripeInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionStripeInfoValidationError{}

// Validate checks the field values on SubscriptionItem with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionItem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionItem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionItemMultiError, or nil if none found.
func (m *SubscriptionItem) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionItem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PriceId

	// no validation rules for ProductId

	// no validation rules for Quantity

	// no validation rules for PriceOwnerId

	// no validation rules for PriceOwnerType

	if all {
		switch v := interface{}(m.GetBizPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionItemValidationError{
					field:  "BizPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionItemValidationError{
					field:  "BizPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBizPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionItemValidationError{
				field:  "BizPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubscriptionItemMultiError(errors)
	}

	return nil
}

// SubscriptionItemMultiError is an error wrapping multiple validation errors
// returned by SubscriptionItem.ValidateAll() if the designated constraints
// aren't met.
type SubscriptionItemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionItemMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionItemMultiError) AllErrors() []error { return m }

// SubscriptionItemValidationError is the validation error returned by
// SubscriptionItem.Validate if the designated constraints aren't met.
type SubscriptionItemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionItemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionItemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionItemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionItemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionItemValidationError) ErrorName() string { return "SubscriptionItemValidationError" }

// Error satisfies the builtin error interface
func (e SubscriptionItemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionItem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionItemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionItemValidationError{}

// Validate checks the field values on SubscriptionItemParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionItemParams) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionItemParams with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionItemParamsMultiError, or nil if none found.
func (m *SubscriptionItemParams) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionItemParams) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for PriceId

	// no validation rules for Quantity

	if all {
		switch v := interface{}(m.GetBizPayload()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionItemParamsValidationError{
					field:  "BizPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionItemParamsValidationError{
					field:  "BizPayload",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBizPayload()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionItemParamsValidationError{
				field:  "BizPayload",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubscriptionItemParamsMultiError(errors)
	}

	return nil
}

// SubscriptionItemParamsMultiError is an error wrapping multiple validation
// errors returned by SubscriptionItemParams.ValidateAll() if the designated
// constraints aren't met.
type SubscriptionItemParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionItemParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionItemParamsMultiError) AllErrors() []error { return m }

// SubscriptionItemParamsValidationError is the validation error returned by
// SubscriptionItemParams.Validate if the designated constraints aren't met.
type SubscriptionItemParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionItemParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionItemParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionItemParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionItemParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionItemParamsValidationError) ErrorName() string {
	return "SubscriptionItemParamsValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionItemParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionItemParams.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionItemParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionItemParamsValidationError{}

// Validate checks the field values on UpdateSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubscriptionRequestMultiError, or nil if none found.
func (m *UpdateSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubscription() == nil {
		err := UpdateSubscriptionRequestValidationError{
			field:  "Subscription",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubscription()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSubscriptionRequestValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSubscriptionRequestValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscription()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSubscriptionRequestValidationError{
				field:  "Subscription",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateSubscriptionRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateSubscriptionRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateSubscriptionRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateSubscriptionRequestMultiError(errors)
	}

	return nil
}

// UpdateSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateSubscriptionRequest.ValidateAll() if the
// designated constraints aren't met.
type UpdateSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubscriptionRequestMultiError) AllErrors() []error { return m }

// UpdateSubscriptionRequestValidationError is the validation error returned by
// UpdateSubscriptionRequest.Validate if the designated constraints aren't met.
type UpdateSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubscriptionRequestValidationError) ErrorName() string {
	return "UpdateSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubscriptionRequestValidationError{}

// Validate checks the field values on UpdateSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateSubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateSubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateSubscriptionMultiError, or nil if none found.
func (m *UpdateSubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateSubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateSubscriptionValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdateSubscriptionValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdateSubscriptionValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdateSubscriptionValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdateSubscriptionMultiError(errors)
	}

	return nil
}

// UpdateSubscriptionMultiError is an error wrapping multiple validation errors
// returned by UpdateSubscription.ValidateAll() if the designated constraints
// aren't met.
type UpdateSubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateSubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateSubscriptionMultiError) AllErrors() []error { return m }

// UpdateSubscriptionValidationError is the validation error returned by
// UpdateSubscription.Validate if the designated constraints aren't met.
type UpdateSubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateSubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateSubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateSubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateSubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateSubscriptionValidationError) ErrorName() string {
	return "UpdateSubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateSubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateSubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateSubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateSubscriptionValidationError{}

// Validate checks the field values on CancelSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CancelSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelSubscriptionRequestMultiError, or nil if none found.
func (m *CancelSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CancelSubscriptionRequestMultiError(errors)
	}

	return nil
}

// CancelSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by CancelSubscriptionRequest.ValidateAll() if the
// designated constraints aren't met.
type CancelSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelSubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelSubscriptionRequestMultiError) AllErrors() []error { return m }

// CancelSubscriptionRequestValidationError is the validation error returned by
// CancelSubscriptionRequest.Validate if the designated constraints aren't met.
type CancelSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelSubscriptionRequestValidationError) ErrorName() string {
	return "CancelSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelSubscriptionRequestValidationError{}

// Validate checks the field values on ResumeSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResumeSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResumeSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResumeSubscriptionRequestMultiError, or nil if none found.
func (m *ResumeSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResumeSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return ResumeSubscriptionRequestMultiError(errors)
	}

	return nil
}

// ResumeSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by ResumeSubscriptionRequest.ValidateAll() if the
// designated constraints aren't met.
type ResumeSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResumeSubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResumeSubscriptionRequestMultiError) AllErrors() []error { return m }

// ResumeSubscriptionRequestValidationError is the validation error returned by
// ResumeSubscriptionRequest.Validate if the designated constraints aren't met.
type ResumeSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResumeSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResumeSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResumeSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResumeSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResumeSubscriptionRequestValidationError) ErrorName() string {
	return "ResumeSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResumeSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResumeSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResumeSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResumeSubscriptionRequestValidationError{}

// Validate checks the field values on GetSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetSubscriptionRequestMultiError, or nil if none found.
func (m *GetSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetSubscriptionRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSubscriptionRequestMultiError(errors)
	}

	return nil
}

// GetSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by GetSubscriptionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSubscriptionRequestMultiError) AllErrors() []error { return m }

// GetSubscriptionRequestValidationError is the validation error returned by
// GetSubscriptionRequest.Validate if the designated constraints aren't met.
type GetSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSubscriptionRequestValidationError) ErrorName() string {
	return "GetSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSubscriptionRequestValidationError{}

// Validate checks the field values on ListSubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSubscriptionRequestMultiError, or nil if none found.
func (m *ListSubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageOffset

	// no validation rules for PageSize

	// no validation rules for Search

	if all {
		switch v := interface{}(m.GetFields()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListSubscriptionRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListSubscriptionRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListSubscriptionRequestValidationError{
				field:  "Fields",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListSubscriptionRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListSubscriptionRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListSubscriptionRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListSubscriptionRequestMultiError(errors)
	}

	return nil
}

// ListSubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by ListSubscriptionRequest.ValidateAll() if the designated
// constraints aren't met.
type ListSubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubscriptionRequestMultiError) AllErrors() []error { return m }

// ListSubscriptionRequestValidationError is the validation error returned by
// ListSubscriptionRequest.Validate if the designated constraints aren't met.
type ListSubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubscriptionRequestValidationError) ErrorName() string {
	return "ListSubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubscriptionRequestValidationError{}

// Validate checks the field values on SubscriptionFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscriptionFilter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscriptionFilter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscriptionFilterMultiError, or nil if none found.
func (m *SubscriptionFilter) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscriptionFilter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionFilterValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionFilterValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionFilterValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUserId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionFilterValidationError{
					field:  "UserId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionFilterValidationError{
					field:  "UserId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUserId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionFilterValidationError{
				field:  "UserId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProvider()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionFilterValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionFilterValidationError{
					field:  "Provider",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProvider()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionFilterValidationError{
				field:  "Provider",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProviderKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscriptionFilterValidationError{
					field:  "ProviderKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscriptionFilterValidationError{
					field:  "ProviderKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProviderKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscriptionFilterValidationError{
				field:  "ProviderKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAnd() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscriptionFilterValidationError{
						field:  fmt.Sprintf("And[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscriptionFilterValidationError{
						field:  fmt.Sprintf("And[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscriptionFilterValidationError{
					field:  fmt.Sprintf("And[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetOr() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubscriptionFilterValidationError{
						field:  fmt.Sprintf("Or[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubscriptionFilterValidationError{
						field:  fmt.Sprintf("Or[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubscriptionFilterValidationError{
					field:  fmt.Sprintf("Or[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SubscriptionFilterMultiError(errors)
	}

	return nil
}

// SubscriptionFilterMultiError is an error wrapping multiple validation errors
// returned by SubscriptionFilter.ValidateAll() if the designated constraints
// aren't met.
type SubscriptionFilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscriptionFilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscriptionFilterMultiError) AllErrors() []error { return m }

// SubscriptionFilterValidationError is the validation error returned by
// SubscriptionFilter.Validate if the designated constraints aren't met.
type SubscriptionFilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscriptionFilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscriptionFilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscriptionFilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscriptionFilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscriptionFilterValidationError) ErrorName() string {
	return "SubscriptionFilterValidationError"
}

// Error satisfies the builtin error interface
func (e SubscriptionFilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscriptionFilter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscriptionFilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscriptionFilterValidationError{}

// Validate checks the field values on ListSubscriptionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListSubscriptionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListSubscriptionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListSubscriptionReplyMultiError, or nil if none found.
func (m *ListSubscriptionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListSubscriptionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalSize

	// no validation rules for FilterSize

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListSubscriptionReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListSubscriptionReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListSubscriptionReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListSubscriptionReplyMultiError(errors)
	}

	return nil
}

// ListSubscriptionReplyMultiError is an error wrapping multiple validation
// errors returned by ListSubscriptionReply.ValidateAll() if the designated
// constraints aren't met.
type ListSubscriptionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubscriptionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubscriptionReplyMultiError) AllErrors() []error { return m }

// ListSubscriptionReplyValidationError is the validation error returned by
// ListSubscriptionReply.Validate if the designated constraints aren't met.
type ListSubscriptionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubscriptionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubscriptionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubscriptionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubscriptionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubscriptionReplyValidationError) ErrorName() string {
	return "ListSubscriptionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubscriptionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubscriptionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubscriptionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubscriptionReplyValidationError{}

// Validate checks the field values on GetMySubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetMySubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMySubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetMySubscriptionRequestMultiError, or nil if none found.
func (m *GetMySubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMySubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GetMySubscriptionRequestValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetMySubscriptionRequestMultiError(errors)
	}

	return nil
}

// GetMySubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by GetMySubscriptionRequest.ValidateAll() if the designated
// constraints aren't met.
type GetMySubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMySubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMySubscriptionRequestMultiError) AllErrors() []error { return m }

// GetMySubscriptionRequestValidationError is the validation error returned by
// GetMySubscriptionRequest.Validate if the designated constraints aren't met.
type GetMySubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMySubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMySubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMySubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMySubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMySubscriptionRequestValidationError) ErrorName() string {
	return "GetMySubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMySubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMySubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMySubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMySubscriptionRequestValidationError{}

// Validate checks the field values on UpdateMySubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMySubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMySubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMySubscriptionRequestMultiError, or nil if none found.
func (m *UpdateMySubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMySubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSubscription() == nil {
		err := UpdateMySubscriptionRequestValidationError{
			field:  "Subscription",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSubscription()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMySubscriptionRequestValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMySubscriptionRequestValidationError{
					field:  "Subscription",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubscription()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMySubscriptionRequestValidationError{
				field:  "Subscription",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateMySubscriptionRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateMySubscriptionRequestValidationError{
					field:  "UpdateMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateMySubscriptionRequestValidationError{
				field:  "UpdateMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateMySubscriptionRequestMultiError(errors)
	}

	return nil
}

// UpdateMySubscriptionRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateMySubscriptionRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateMySubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMySubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMySubscriptionRequestMultiError) AllErrors() []error { return m }

// UpdateMySubscriptionRequestValidationError is the validation error returned
// by UpdateMySubscriptionRequest.Validate if the designated constraints
// aren't met.
type UpdateMySubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMySubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMySubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMySubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMySubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMySubscriptionRequestValidationError) ErrorName() string {
	return "UpdateMySubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMySubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMySubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMySubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMySubscriptionRequestValidationError{}

// Validate checks the field values on UpdateMySubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateMySubscription) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateMySubscription with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateMySubscriptionMultiError, or nil if none found.
func (m *UpdateMySubscription) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateMySubscription) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := UpdateMySubscriptionValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateMySubscriptionMultiError(errors)
	}

	return nil
}

// UpdateMySubscriptionMultiError is an error wrapping multiple validation
// errors returned by UpdateMySubscription.ValidateAll() if the designated
// constraints aren't met.
type UpdateMySubscriptionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateMySubscriptionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateMySubscriptionMultiError) AllErrors() []error { return m }

// UpdateMySubscriptionValidationError is the validation error returned by
// UpdateMySubscription.Validate if the designated constraints aren't met.
type UpdateMySubscriptionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateMySubscriptionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateMySubscriptionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateMySubscriptionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateMySubscriptionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateMySubscriptionValidationError) ErrorName() string {
	return "UpdateMySubscriptionValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateMySubscriptionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateMySubscription.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateMySubscriptionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateMySubscriptionValidationError{}

// Validate checks the field values on ListMySubscriptionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMySubscriptionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMySubscriptionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMySubscriptionRequestMultiError, or nil if none found.
func (m *ListMySubscriptionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMySubscriptionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PageOffset

	// no validation rules for PageSize

	// no validation rules for Search

	if all {
		switch v := interface{}(m.GetFields()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMySubscriptionRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMySubscriptionRequestValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMySubscriptionRequestValidationError{
				field:  "Fields",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListMySubscriptionRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListMySubscriptionRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListMySubscriptionRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListMySubscriptionRequestMultiError(errors)
	}

	return nil
}

// ListMySubscriptionRequestMultiError is an error wrapping multiple validation
// errors returned by ListMySubscriptionRequest.ValidateAll() if the
// designated constraints aren't met.
type ListMySubscriptionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMySubscriptionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMySubscriptionRequestMultiError) AllErrors() []error { return m }

// ListMySubscriptionRequestValidationError is the validation error returned by
// ListMySubscriptionRequest.Validate if the designated constraints aren't met.
type ListMySubscriptionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMySubscriptionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMySubscriptionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMySubscriptionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMySubscriptionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMySubscriptionRequestValidationError) ErrorName() string {
	return "ListMySubscriptionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListMySubscriptionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMySubscriptionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMySubscriptionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMySubscriptionRequestValidationError{}

// Validate checks the field values on ListMySubscriptionReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListMySubscriptionReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListMySubscriptionReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListMySubscriptionReplyMultiError, or nil if none found.
func (m *ListMySubscriptionReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListMySubscriptionReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalSize

	// no validation rules for FilterSize

	for idx, item := range m.GetItems() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListMySubscriptionReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListMySubscriptionReplyValidationError{
						field:  fmt.Sprintf("Items[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListMySubscriptionReplyValidationError{
					field:  fmt.Sprintf("Items[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListMySubscriptionReplyMultiError(errors)
	}

	return nil
}

// ListMySubscriptionReplyMultiError is an error wrapping multiple validation
// errors returned by ListMySubscriptionReply.ValidateAll() if the designated
// constraints aren't met.
type ListMySubscriptionReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListMySubscriptionReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListMySubscriptionReplyMultiError) AllErrors() []error { return m }

// ListMySubscriptionReplyValidationError is the validation error returned by
// ListMySubscriptionReply.Validate if the designated constraints aren't met.
type ListMySubscriptionReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListMySubscriptionReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListMySubscriptionReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListMySubscriptionReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListMySubscriptionReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListMySubscriptionReplyValidationError) ErrorName() string {
	return "ListMySubscriptionReplyValidationError"
}

// Error satisfies the builtin error interface
func (e ListMySubscriptionReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListMySubscriptionReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListMySubscriptionReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListMySubscriptionReplyValidationError{}
